var mongoose = require('mongoose');
var weaponTypes = ['Rock','Scissors','Paper'];
var schTurn = new mongoose.Schema({
    turnDate: Date,
    participants: [{userid: mongoose.Schema.Types.ObjectId, 
                    weapon: {type: String, enum: weaponTypes}}]
});
var modTurn = mongoose.model('turn', schTurn);

function findParticipant(participants, user){
    var index = 0;
    while(index < participants.length){
        if(participants[index].userid == user)
            return index
        index++;
    }
    return -1;
}

//************************************************************************************************************
// function     : d4-roshamturn.takeTurn         <-- no longer used
// developer    : Kai
// developed on : 5/19/2014
// arguments    : turn object {userid, weapon}
//                callback function (error, boolean)
//************************************************************************************************************
exports.takeTurn = function(turn, callback){
/*    if(!turn){
        return callback({'error': 'What turn you talkin bout?'}, undefined);
    };
    if (!turn.userid){
        return callback({'error': 'Who is taking this turn anyway?'}, undefined);
    };
    if((!turn.weapon)||(weaponTypes.indexOf(turn.weapon) < 0)){
        return callback({'error': 'Please provide a weapon that might actually do some harm.'}, undefined);
    };

    var user = require('d4-user');
    user.validateUser({'_id':turn.userid}, function(err, found){
        if (err){
            return callback({'error': err}, undefined);
        };
        if (found){
            var query = modTurn.findOne().where('turnDate').equals(undefined);
            query.exec(function(err, curTurn){
                if(err){
                    return callback({'error': err}, undefined);
                }
                if(curTurn){
                    var userindex = findParticipant(curTurn.participants, turn.userid);
                    if(userindex < 0){
                        curTurn.participants.push(turn); 
                    }
                    else{
                        curTurn.participants[userindex].weapon = turn.weapon;
                    };
                    curTurn.save(function(err){
                        if(err)
                            return callback({'error': err}, undefined);
                        
                        return callback(undefined, true);
                    });
                }
                else{
                    modTurn.create({'turnDate': undefined, 
                                    'participants': [{'userid':turn.userid, 
                                                      'weapon':turn.weapon}]}, function(err, newTurn){
                        if(err){
                            return callback({'error': err}, undefined);
                        };
                        return callback(undefined, true);
                                                          
                    });
                };
            });
        }
        else{
            return callback({'error': 'Who is taking this turn anyway?'}, undefined);
        };
    });    */
}

//************************************************************************************************************
// function     : d4-roshamturn.getCurrentTurn   <-- no longer used
// developer    : Kai
// developed on : 5/19/2014
// arguments    : userid
//                callback function (error, weapon) (weapon will be 'None' if you haven't taken your turn yet
//************************************************************************************************************
exports.getCurrentTurn = function(userid, callback){
/*    if(!userid){
        return callback({'error': 'Do you want to supply a user?'}, undefined);
    };
    
    var user = require('d4-user');
    user.validateUser({'_id':userid}, function(err, found){
        if (err){
            return callback({'error': err}, undefined);
        };
        if (found){
            var query = modTurn.findOne().where('turnDate').equals(undefined);
            query.exec(function(err, curTurn){
                if(err){
                    return callback({'error': err}, undefined);
                };
                if(curTurn){
                    var userindex = findParticipant(curTurn.participants, userid);
                    if(userindex < 0){
                        return callback(undefined, 'None');
                    }
                    return callback(undefined, curTurn.participants[userindex].weapon);
                }
                else{
                    return callback(undefined, 'None');
                }
            });
        }
        else{
            return callback({'error': 'Do you want to supply a REAL user?'}, undefined);
        }
    });     */
};


//************************************************************************************************************
// function     : d4-roshamturn.generateTurn
// developer    : Kai
// developed on : 5/23/2014
// arguments    : callback function (error, turnDate) 
//************************************************************************************************************
exports.generateTurn = function(callback){
    var result = require('d4-roshamresult');
    var roshamuser = require('d4-roshamuser');
    
    var newTurn = new modTurn({'turnDate': new Date});
    var query = roshamuser.roshamuserModel.find();
    query.where('weapon').in(weaponTypes);
    query.select('userid weapon -_id');
    query.exec(function(err, foundUsers){
        if(err){
            return callback({'error': err}, undefined);
        }
        else{
            newTurn.participants = foundUsers;
            var battle = {'turnDate': newTurn.turnDate},
                resultCount = 0 ;
            if (newTurn.participants <=1){
                return callback({error:'Put down that magazine and stop playing with yourself.'}, undefined);
            }
            else{
                for(var i=0; i<newTurn.participants.length - 1; i++){
                    battle.player1 = newTurn.participants[i].userid;
                    battle.weapon1 = newTurn.participants[i].weapon;
                    for(var j=i+1; j<newTurn.participants.length; j++){
                        battle.player2 = newTurn.participants[j].userid;
                        battle.weapon2 = newTurn.participants[j].weapon;

                        result.logResult(battle, function(err, newResult){
                            resultCount++;
                            console.log('logresult' + resultCount + ' ' + i + ' ' + (((newTurn.participants.length-1)*newTurn.participants.length)/2));
                            console.log(resultCount === (((newTurn.participants.length-1)*newTurn.participants.length)/2));
                            if(err){
                                return callback({'error': err.error}, undefined);
                            } else if (resultCount === (((newTurn.participants.length-1)*newTurn.participants.length)/2)) {
                                newTurn.save(function(err){
                                    if(err){
                                        return callback({'error': err.error}, undefined);
                                    }
                                    else{
                                        return callback(undefined, newTurn);
                                    }
                                });
                            }
                        });
                    }
                }
            }
        }
    });
};